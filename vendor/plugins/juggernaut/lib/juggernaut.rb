require "yaml"
require "socket"
require "json"

module Juggernaut
  begin
   CONFIG = YAML::load(ERB.new(IO.read("#{RAILS_ROOT}/config/juggernaut.yml")).result).freeze
  rescue
   $stderr.write("[!] Juggernaut can't find its config file, try to reinstall Juggernaut: rake juggernaut:reinstall\n")
   exit -1
  end
    
  def self.send_data(data, channels = nil)
    @socket = TCPSocket.new(CONFIG["PUSH_HELPER_HOST"], CONFIG["PUSH_PORT"])
    fc = {
      :message => prepare(data), 
      :secret => CONFIG["SECRET"], 
      :broadcast => 1,
      :channels => channels || CONFIG["DEFAULT_CHANNELS"]
    }
    @socket.print JSON.unparse(fc)
    @socket.flush
  rescue
    false
  ensure
    @socket.close if @socket
  end
  
  #IMPORTANT: If you use the unique id when the swf connects to the push server, 
  #IE. <%= listen_to_juggernaut_channels(session[:juggernaut_channels], @user.id) %>
  #Note the @user.id above. If you include the "@user.id" or some sort of equivalent unique id
  # then this send_to will take in that unique_id in the "to" variable. 
  # HOWEVER, if you do NOT include a unique identifier, the user's session_id is used as the connection's
  # unique identifier. In that case, to use the action below you need to include the session_id 
  # as the "to"
  def self.send_to(to, data = "")
    @socket = TCPSocket.new(CONFIG["PUSH_HELPER_HOST"], CONFIG["PUSH_PORT"])
    fc = {
      :message => prepare(data),
      :secret => CONFIG["SECRET"], 
      :broadcast => 0,
      :channels => nil,
      :to => to.to_s,
      :function => "sendTo"
    }
    @socket.print JSON.unparse(fc)
    @socket.flush
  rescue
    false
  ensure
    @socket.close if @socket
  end
  
  #Add channel(s) to a specific user
  #channels can be an array, or a single string element
  def self.add_channel(id, channels = nil)
    @socket = TCPSocket.new(CONFIG["PUSH_HELPER_HOST"], CONFIG["PUSH_PORT"])
    fc = {
      :message => ("addChannel"),
      :secret => CONFIG["SECRET"], 
      :broadcast => 0,
      :channels => channels,
      :id => id.to_s,
      :function => "addChannel"
    }
    @socket.print JSON.unparse(fc)
    @socket.flush
  rescue
    false
  ensure
    @socket.close if @socket
  end
  
  #Remove channel(s) from a specific user
  ##channels can be an array, or a single string element
  def self.remove_channel(id, channels = nil)
    @socket = TCPSocket.new(CONFIG["PUSH_HELPER_HOST"], CONFIG["PUSH_PORT"])
      fc = {
        :message => ("removeChannel"),
        :secret => CONFIG["SECRET"], 
        :broadcast => 0,
        :channels => channels,
        :id => id.to_s,
        :function => "removeChannel"
      }
      @socket.print JSON.unparse(fc)
      @socket.flush
    rescue
      false
    ensure
      @socket.close if @socket
  end
  
  def self.prepare(data)
   CONFIG["BASE64"] ? Base64.encode64(data) : data
  end
  
  module RenderExtension
    def self.included(base)
      base.send :include, InstanceMethods
    end
  
    module InstanceMethods
      def self.included(base)
        base.class_eval do
#          alias_method_chain :render, :juggernaut
          alias_method :render_without_juggernaut, :render
          #this is dangerous, should not modify the original render method
#          alias_method :render, :render_with_juggernaut
        end
      end
    
      def render_with_juggernaut(options = {}, &block)
        juggernaut = nil || options.delete(:juggernaut) if options.is_a?(Hash)
        if juggernaut
          # added support for pushing javascript generated by RJS (toggled by :update => true)
          result =  options[:update] ?
                      ActionView::Helpers::PrototypeHelper::JavaScriptGenerator.new(@template, &block).to_s :
                      render_to_string(options, &block)
          channels = case juggernaut
            when true : Juggernaut::CONFIG['DEFAULT_CHANNELS']
            else Array(juggernaut)
            end
          Juggernaut.send_data(result, channels)
          render :nothing => true
        else
          render_without_juggernaut(options, &block)
        end
      end    
    end
  
  end
    
  def self.html_escape(s)
   s.to_s.gsub(/&/, "&amp;").gsub(/\"/, "&quot;").gsub(/>/, "&gt;").gsub(/</, "&lt;")
  end
      
  def self.string_escape(s)
   s.gsub(/[']/, '\\\\\'')
  end
      
  def self.parse_string(s)
   s.gsub(/\r\n|\n|\r/, "\\n").gsub(/["']/) { |m| "\\#{m}" }
  end
      
  def self.html_and_string_escape(s)
   html_escape(string_escape(s))
  end
    

end
